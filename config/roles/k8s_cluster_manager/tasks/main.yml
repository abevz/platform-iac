---
# =================================================================
# ТАСК 1: ИНИЦИАЛИЗАЦИЯ CONTROL PLANE
# =================================================================
- name: 1. Initialize Kubernetes Cluster (Control Plane)
  tags: [kubeadm_init]
  when: inventory_hostname in groups['k8s_master']
  block:
    - name: Check if cluster is already initialized
      ansible.builtin.stat:
        path: /etc/kubernetes/admin.conf
      register: kubeconfig_exists

    - name: Get hostname and FQDN
      ansible.builtin.setup:
        filter: ansible_hostname,ansible_fqdn
      register: hostname_facts

    - name: Create kubeadm configuration file with DNS hostname support
      ansible.builtin.template:
        dest: /tmp/kubeadm-config.yaml
        src: kubeadm-config.yaml.j2 # ПРИМЕЧАНИЕ: Я преобразовал 'content' в шаблон
        mode: '0644'
      when: not kubeconfig_exists.stat.exists

    - name: Initialize Kubernetes cluster with custom configuration
      ansible.builtin.command: kubeadm init --config=/tmp/kubeadm-config.yaml
      register: kubeadm_init_result
      when: not kubeconfig_exists.stat.exists
      changed_when: true

    - name: Create .kube directory for root
      ansible.builtin.file:
        path: /root/.kube
        state: directory
        mode: '0755'
      when: kubeadm_init_result.changed

    - name: Copy admin.conf to root's kube config
      ansible.builtin.copy:
        src: /etc/kubernetes/admin.conf
        dest: /root/.kube/config
        remote_src: yes
        owner: root
        group: root
        mode: '0644'
      when: kubeadm_init_result.changed

    - name: Create .kube directory for regular user ({{ ansible_user }})
      ansible.builtin.file:
        path: "/home/{{ ansible_user }}/.kube"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      when: kubeadm_init_result.changed

    - name: Copy admin.conf to user's kube config
      ansible.builtin.copy:
        src: /etc/kubernetes/admin.conf
        dest: "/home/{{ ansible_user }}/.kube/config"
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      when: kubeadm_init_result.changed

    - name: Extract join command
      ansible.builtin.shell: kubeadm token create --print-join-command
      register: join_command_output
      when: kubeadm_init_result.changed

    - name: Save join command to file on CP
      ansible.builtin.copy:
        content: "{{ join_command_output.stdout }}"
        dest: /tmp/kubeadm_join_command.sh
        mode: '0755'
      when: kubeadm_init_result.changed

    - name: Fetch join command to local machine (Ansible Controller)
      ansible.builtin.fetch:
        src: /tmp/kubeadm_join_command.sh
        dest: /tmp/kubeadm_join_command.sh
        flat: yes
      when: kubeadm_init_result.changed

# =================================================================
# ТАСК 2: УСТАНОВКА CALICO CNI
# =================================================================
- name: 2. Install Calico CNI Plugin (Control Plane)
  tags: [cni]
  when: inventory_hostname in groups['k8s_master']
  block:
    - name: Check if Calico is already installed
      ansible.builtin.shell: kubectl get pods -n calico-system --no-headers 2>/dev/null | wc -l
      register: calico_pods_count
      failed_when: false
      changed_when: false

    - name: Install Calico CNI
      ansible.builtin.shell: |
        kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/tigera-operator.yaml
        kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/custom-resources.yaml
      when: calico_pods_count.stdout == "0"
      register: calico_install_result
      changed_when: true

    - name: Wait for Calico pods to be created
      ansible.builtin.shell: kubectl get pods -n calico-system --no-headers
      register: calico_pod_list
      until: calico_pod_list.stdout_lines | length > 0
      retries: 20
      delay: 15
      when: calico_install_result.changed
      changed_when: false

    - name: Wait for Calico Deployments to be available
      ansible.builtin.command: "kubectl wait --for=condition=Available deployment --all -n calico-system --timeout=300s"
      changed_when: true
      
    - name: Wait for Calico DaemonSet to be ready
      ansible.builtin.command: "kubectl rollout status daemonset/calico-node -n calico-system --timeout=300s"
      changed_when: true

# =================================================================
# ТАСК 3: ПРИСОЕДИНЕНИЕ WORKER НОД
# =================================================================
- name: 3. Join Worker Nodes to Cluster
  tags: [kubeadm_join]
  when: inventory_hostname in groups['k8s_worker']
  block:
    - name: Check if node is already part of cluster
      ansible.builtin.stat:
        path: /etc/kubernetes/kubelet.conf
      register: kubelet_conf_exists

    - name: Copy join command to worker nodes
      ansible.builtin.copy:
        src: /tmp/kubeadm_join_command.sh # Взято с локальной машины Ansible
        dest: /tmp/kubeadm_join_command.sh
        mode: '0755'
      when: not kubelet_conf_exists.stat.exists

    - name: Join worker nodes to cluster
      ansible.builtin.shell: /tmp/kubeadm_join_command.sh
      when: not kubelet_conf_exists.stat.exists
      register: join_result
      changed_when: true

# =================================================================
# ТАСК 4: ВЕРИФИКАЦИЯ КЛАСТЕРА И CSR
# =================================================================
- name: 4. Verify Cluster Status and Approve CSRs (Control Plane)
  tags: [verify, kubeadm_init, kubeadm_join] # Запускается после init или join
  when: inventory_hostname in groups['k8s_master']
  block:
    - name: Wait for all nodes to report Ready status
      ansible.builtin.command: "kubectl wait --for=condition=Ready nodes --all --timeout=300s"

    - name: Wait until all worker CSRs are created
      ansible.builtin.command: >
        kubectl get csr -o jsonpath='{.items[?(@.spec.signerName=="kubernetes.io/kubelet-serving")].metadata.name}'
      register: pending_csr_names
      until: "pending_csr_names.stdout.split(' ') | length >= (groups['k8s_worker'] | length)"
      retries: 30
      delay: 10
      changed_when: false

    - name: Approve all found kubelet serving CSRs
      ansible.builtin.command: "kubectl certificate approve {{ item }}"
      loop: "{{ pending_csr_names.stdout.split(' ') }}"
      when: pending_csr_names.stdout | length > 0
      changed_when: true

    - name: Final cluster status verification
      ansible.builtin.shell: kubectl get nodes -o wide
      register: final_cluster_status
      changed_when: false

    - name: Display final cluster status
      ansible.builtin.debug:
        msg: |
          Final Cluster Status:
          {{ final_cluster_status.stdout }}

# =================================================================
# ТАСК 5: СЕКРЕТЫ HARBOR
# =================================================================
- name: 5. Configure Harbor Integration (Secrets)
  tags: [harbor_secret]
  when: inventory_hostname in groups['k8s_master']
  block:
    - name: Check if Harbor robot token is provided
      ansible.builtin.fail:
        msg: "Harbor robot token is not defined. Please pass it using -e 'HARBOR_ROBOT_TOKEN=your_token'"
      when: harbor_robot_token | length == 0

    - name: Create Harbor pull secret in target namespaces
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: registry-creds
            namespace: "{{ item }}"
          type: kubernetes.io/dockerconfigjson
          data:
            .dockerconfigjson: >-
              {{
                {
                  "auths": {
                    (harbor_hostname): {
                      "username": harbor_robot_username,
                      "password": harbor_robot_token,
                      "auth": (harbor_robot_username + ":" + harbor_robot_token) | b64encode
                    }
                  }
                } | to_json | b64encode
              }}
      loop: "{{ target_namespaces }}"
